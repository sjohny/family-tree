<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Our Family Tree</title>

  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;500;600;700&family=Lora:wght@400;500&family=Source+Sans+3:wght@300;400;500;600&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg: #faf7f2; --bg-warm: #f5f0e8; --card: #ffffff;
      --text: #3a3028; --text-soft: #7a6f63; --text-muted: #a89e93;
      --accent: #8b7355; --accent-light: #c4a882; --accent-warm: #d4a574;
      --border: #e6ddd1; --border-light: #efe8de; --gold: #c9a96e;
      --shadow: rgba(60,48,30,0.08); --shadow-md: rgba(60,48,30,0.12);
      --line-color: #b8ad9e; --male: #7a92a8; --female: #b08a9a;
    }
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      font-family:'Source Sans 3',sans-serif;
      background:var(--bg);
      color:var(--text);
      min-height:100vh;
    }
    body::before {
      content:'';
      position:fixed; inset:0;
      background:
        radial-gradient(ellipse at 20% 20%,rgba(201,169,110,0.06) 0%,transparent 50%),
        radial-gradient(ellipse at 80% 80%,rgba(176,138,154,0.05) 0%,transparent 50%);
      pointer-events:none;
      z-index:0;
    }
    body.dragging { user-select:none; cursor:grabbing; }
    body.dragging * { cursor:grabbing !important; }

    /* Header */
    .app-header {
      position:sticky; top:0; z-index:100;
      background:rgba(250,247,242,0.92);
      backdrop-filter:blur(20px);
      border-bottom:1px solid var(--border-light);
      padding:0 2rem;
    }
    .header-inner {
      max-width:1400px; margin:0 auto;
      display:flex; align-items:center; justify-content:space-between;
      height:64px;
    }
    .header-title {
      font-family:'Playfair Display',serif;
      font-size:1.5rem; font-weight:600;
      cursor:pointer;
      user-select:none;
    }
    .header-title span { color:var(--accent-warm); }
    .header-actions { display:flex; gap:0.5rem; align-items:center; }

    /* Buttons */
    .btn {
      display:inline-flex; align-items:center; gap:0.4rem;
      padding:0.5rem 1rem;
      border:1px solid var(--border);
      border-radius:8px;
      background:var(--card);
      color:var(--text);
      font-family:'Source Sans 3',sans-serif;
      font-size:0.85rem; font-weight:500;
      cursor:pointer;
      transition:all 0.2s;
      white-space:nowrap;
    }
    .btn:hover { border-color:var(--accent-light); box-shadow:0 2px 8px var(--shadow); }
    .btn-primary { background:var(--accent); color:#fff; border-color:var(--accent); }
    .btn-primary:hover { background:#7a6348; }
    .btn-danger { color:#c0392b; border-color:#e8c4c0; }
    .btn-danger:hover { background:#fdf0ef; border-color:#c0392b; }
    .btn-sm { padding:0.35rem 0.75rem; font-size:0.8rem; }
    .btn-icon { width:36px; height:36px; padding:0; display:inline-flex; align-items:center; justify-content:center; border-radius:8px; }

    /* Tree Canvas */
    .tree-container { position:relative; z-index:1; min-height:calc(100vh - 64px); overflow:auto; }
    .tree-title-section { text-align:center; padding:2rem 0 1rem; }
    .tree-title-section h1 { font-family:'Playfair Display',serif; font-size:2.2rem; font-weight:600; }
    .tree-title-section .subtitle { font-family:'Lora',serif; font-size:0.95rem; color:var(--text-muted); font-style:italic; }

    /* Tree absolute-positioned canvas */
    #treeCanvas { position:relative; margin:0 auto; }
    #treeSvg { position:absolute; top:0; left:0; pointer-events:none; z-index:0; }
    #treeSvg line { stroke:var(--line-color); stroke-width:1.8; stroke-linecap:round; }

    /* Member card (absolutely positioned) */
    .tree-node {
      position:absolute;
      display:flex; flex-direction:column; align-items:center; gap:4px;
      cursor:pointer;
      transition:transform 0.15s;
      z-index:1;
      touch-action:none; /* important for pointer drag */
    }
    .tree-node:hover { transform:translateY(-3px); }
    .tree-node.drag-hint { cursor:grab; }
    .tree-node .photo {
      width:76px; height:76px;
      border-radius:50%;
      border:3px solid var(--border);
      overflow:hidden;
      background:var(--bg-warm);
      display:flex; align-items:center; justify-content:center;
      box-shadow:0 3px 12px var(--shadow);
      transition:all 0.3s;
    }
    .tree-node:hover .photo { border-color:var(--accent-light); box-shadow:0 6px 20px var(--shadow-md); }
    .tree-node .photo img { width:100%; height:100%; object-fit:cover; }
    .tree-node .photo .initials { font-family:'Playfair Display',serif; font-size:1.3rem; font-weight:500; color:var(--text-muted); }
    .tree-node .photo.male { border-color:var(--male); }
    .tree-node .photo.female { border-color:var(--female); }
    .tree-node .name {
      font-family:'Lora',serif;
      font-size:0.78rem; font-weight:500;
      text-align:center; line-height:1.2;
      max-width:120px;
    }
    .tree-node .dates { font-size:0.68rem; color:var(--text-muted); text-align:center; }
    .tree-node .maiden { font-size:0.68rem; color:var(--text-soft); font-style:italic; }

    /* Generation labels */
    .gen-label-abs {
      position:absolute;
      font-family:'Lora',serif;
      font-size:0.65rem;
      text-transform:uppercase;
      letter-spacing:0.12em;
      color:var(--text-muted);
      z-index:2;
      white-space:nowrap;
      user-select:none;
    }

    /* Empty state */
    .empty-state { text-align:center; padding:4rem 2rem; max-width:500px; margin:0 auto; }
    .empty-state .tree-icon { font-size:4rem; margin-bottom:1.5rem; opacity:0.5; }
    .empty-state h2 { font-family:'Playfair Display',serif; font-size:1.6rem; font-weight:500; margin-bottom:0.75rem; }
    .empty-state p { color:var(--text-soft); font-size:0.95rem; margin-bottom:1.5rem; line-height:1.6; }

    /* Modal */
    .modal-overlay {
      position:fixed; inset:0;
      background:rgba(58,48,40,0.4);
      backdrop-filter:blur(4px);
      z-index:1000;
      display:flex; align-items:center; justify-content:center;
      padding:1rem;
      opacity:0; visibility:hidden;
      transition:all 0.3s;
    }
    .modal-overlay.active { opacity:1; visibility:visible; }
    .modal {
      background:var(--card);
      border-radius:16px;
      box-shadow:0 20px 60px rgba(58,48,40,0.25);
      width:100%; max-width:520px;
      max-height:90vh;
      overflow-y:auto;
      transform:translateY(20px);
      transition:transform 0.3s;
    }
    .modal-overlay.active .modal { transform:translateY(0); }
    .modal-header { padding:1.5rem 1.5rem 0; display:flex; align-items:center; justify-content:space-between; }
    .modal-header h2 { font-family:'Playfair Display',serif; font-size:1.3rem; font-weight:600; }
    .modal-body { padding:1.25rem 1.5rem 1.5rem; }
    .modal-footer { padding:0 1.5rem 1.5rem; display:flex; gap:0.5rem; justify-content:flex-end; }

    /* Form */
    .form-row { display:flex; gap:0.75rem; margin-bottom:0.75rem; }
    .form-group { flex:1; margin-bottom:0.75rem; }
    .form-row .form-group { margin-bottom:0; }
    .form-group label {
      display:block;
      font-size:0.78rem; font-weight:500;
      color:var(--text-soft);
      margin-bottom:0.3rem;
      text-transform:uppercase;
      letter-spacing:0.05em;
    }
    .form-group input,.form-group select,.form-group textarea {
      width:100%;
      padding:0.6rem 0.8rem;
      border:1px solid var(--border);
      border-radius:8px;
      font-family:'Source Sans 3',sans-serif;
      font-size:0.9rem;
      color:var(--text);
      background:var(--bg);
      transition:border-color 0.2s;
    }
    .form-group input:focus,.form-group select:focus,.form-group textarea:focus {
      outline:none;
      border-color:var(--accent-light);
      box-shadow:0 0 0 3px rgba(196,168,130,0.15);
    }
    .form-group textarea { resize:vertical; min-height:60px; }
    .form-group .help-text { font-size:0.72rem; color:var(--text-muted); margin-top:0.25rem; }
    .photo-preview-row { display:flex; gap:0.75rem; align-items:flex-end; }
    .photo-preview-row .form-group { flex:1; }
    .photo-preview {
      width:56px; height:56px;
      border-radius:50%;
      border:2px solid var(--border);
      overflow:hidden;
      background:var(--bg-warm);
      flex-shrink:0;
      display:flex; align-items:center; justify-content:center;
    }
    .photo-preview img { width:100%; height:100%; object-fit:cover; }
    .photo-preview .preview-placeholder { font-size:0.65rem; color:var(--text-muted); text-align:center; }

    /* Detail Panel */
    .detail-panel {
      position:fixed;
      right:-420px;
      top:64px;
      width:400px;
      height:calc(100vh - 64px);
      background:var(--card);
      border-left:1px solid var(--border);
      box-shadow:-4px 0 20px var(--shadow);
      z-index:200;
      transition:right 0.35s cubic-bezier(0.4,0,0.2,1);
      overflow-y:auto;
      padding:1.5rem;
    }
    .detail-panel.open { right:0; }
    .detail-panel-header { display:flex; justify-content:space-between; align-items:flex-start; margin-bottom:1.5rem; }
    .detail-photo {
      width:100px; height:100px;
      border-radius:50%;
      border:3px solid var(--border);
      overflow:hidden;
      background:var(--bg-warm);
      margin:0 auto 1rem;
      display:flex; align-items:center; justify-content:center;
    }
    .detail-photo.male { border-color:var(--male); }
    .detail-photo.female { border-color:var(--female); }
    .detail-photo img { width:100%; height:100%; object-fit:cover; }
    .detail-photo .initials { font-family:'Playfair Display',serif; font-size:2rem; color:var(--text-muted); }
    .detail-name { font-family:'Playfair Display',serif; font-size:1.4rem; text-align:center; margin-bottom:0.25rem; }
    .detail-maiden { text-align:center; font-style:italic; color:var(--text-soft); font-size:0.9rem; margin-bottom:0.5rem; }
    .detail-dates { text-align:center; color:var(--text-muted); font-size:0.85rem; margin-bottom:1rem; }
    .detail-bio {
      color:var(--text-soft);
      font-size:0.9rem;
      line-height:1.6;
      padding:1rem;
      background:var(--bg);
      border-radius:8px;
      margin-bottom:1rem;
      white-space:pre-wrap;
    }
    .detail-relations { margin-top:1rem; }
    .detail-relations h4 {
      font-family:'Lora',serif;
      font-size:0.85rem;
      font-weight:500;
      color:var(--text-soft);
      text-transform:uppercase;
      letter-spacing:0.05em;
      margin-bottom:0.5rem;
    }
    .detail-rel-item { display:flex; align-items:center; gap:0.5rem; padding:0.5rem 0; cursor:pointer; }
    .detail-rel-item:hover { color:var(--accent); }
    .detail-rel-item .mini-photo {
      width:32px; height:32px;
      border-radius:50%;
      border:2px solid var(--border);
      overflow:hidden;
      background:var(--bg-warm);
      display:flex; align-items:center; justify-content:center;
      flex-shrink:0;
    }
    .detail-rel-item .mini-photo img { width:100%; height:100%; object-fit:cover; }
    .detail-rel-item .mini-photo .initials { font-size:0.6rem; color:var(--text-muted); }
    .detail-actions { display:flex; gap:0.5rem; margin-top:1.5rem; padding-top:1rem; border-top:1px solid var(--border-light); }

    /* Dropdown */
    .dropdown { position:relative; }
    .dropdown-menu {
      position:absolute;
      top:100%; right:0;
      margin-top:4px;
      background:var(--card);
      border:1px solid var(--border);
      border-radius:10px;
      box-shadow:0 8px 24px var(--shadow-md);
      min-width:180px;
      z-index:300;
      overflow:hidden;
      display:none;
    }
    .dropdown-menu.show { display:block; }
    .dropdown-menu button {
      display:flex; align-items:center; gap:0.5rem;
      width:100%;
      padding:0.65rem 1rem;
      border:none;
      background:none;
      font-family:'Source Sans 3',sans-serif;
      font-size:0.85rem;
      color:var(--text);
      cursor:pointer;
      text-align:left;
    }
    .dropdown-menu button:hover { background:var(--bg-warm); }
    .dropdown-menu hr { border:none; border-top:1px solid var(--border-light); margin:0; }

    /* Toast */
    .toast {
      position:fixed;
      bottom:2rem;
      left:50%;
      transform:translateX(-50%) translateY(80px);
      background:var(--text);
      color:#fff;
      padding:0.75rem 1.25rem;
      border-radius:10px;
      font-size:0.85rem;
      z-index:2000;
      transition:transform 0.3s;
      box-shadow:0 8px 24px rgba(0,0,0,0.2);
      max-width:min(720px, calc(100vw - 2rem));
      text-align:center;
    }
    .toast.show { transform:translateX(-50%) translateY(0); }

    @media (max-width:768px) {
      .app-header { padding:0 1rem; }
      .header-title { font-size:1.2rem; }
      .tree-title-section h1 { font-size:1.8rem; }
      .detail-panel { width:100%; right:-100%; }
      .tree-node .photo { width:60px; height:60px; }
      .tree-node .name { font-size:0.7rem; }
    }
    ::-webkit-scrollbar { width:8px; }
    ::-webkit-scrollbar-track { background:var(--bg); }
    ::-webkit-scrollbar-thumb { background:var(--border); border-radius:4px; }
  </style>
</head>

<body>
  <header class="app-header">
    <div class="header-inner">
      <div class="header-title" onclick="closeDetailPanel()">Family<span>Tree</span></div>
      <div class="header-actions">
        <button class="btn btn-primary" onclick="openAddMember()">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
            <line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/>
          </svg>
          Add Person
        </button>

        <button class="btn" onclick="openRelationshipModal()">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M16 21v-2a4 4 0 00-4-4H6a4 4 0 00-4-4v2"/>
            <circle cx="9" cy="7" r="4"/>
            <path d="M22 21v-2a4 4 0 00-3-3.87"/>
            <path d="M16 3.13a4 4 0 010 7.75"/>
          </svg>
          Add Relation
        </button>

        <div class="dropdown">
          <button class="btn btn-icon" onclick="toggleMenu()" aria-label="Menu">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="1"/><circle cx="12" cy="5" r="1"/><circle cx="12" cy="19" r="1"/>
            </svg>
          </button>
          <div class="dropdown-menu" id="dropdownMenu">
            <button onclick="openSettings()">âš™ï¸ Settings</button>
            <button onclick="exportData()">ğŸ“ Export Data</button>
            <button onclick="document.getElementById('importInput').click()">ğŸ“¥ Import Data</button>
            <hr>
            <button onclick="loadSampleData()">ğŸŒ³ Load Sample Tree</button>
            <button onclick="resetLayout()">ğŸ§¹ Reset manual layout</button>
          </div>
        </div>

        <input type="file" id="importInput" accept=".json" style="display:none" onchange="importData(event)">
      </div>
    </div>
  </header>

  <div class="tree-container" id="treeContainer">
    <div class="tree-title-section">
      <h1 id="treeTitle">Our Family Tree</h1>
      <div class="subtitle" id="treeSubtitle"></div>
    </div>
    <div id="treeCanvas"></div>
  </div>

  <div class="detail-panel" id="detailPanel">
    <div class="detail-panel-header">
      <div></div>
      <button class="btn btn-icon btn-sm" onclick="closeDetailPanel()" aria-label="Close details">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
        </svg>
      </button>
    </div>
    <div id="detailContent"></div>
  </div>

  <!-- Member Modal -->
  <div class="modal-overlay" id="memberModal">
    <div class="modal">
      <div class="modal-header">
        <h2 id="memberModalTitle">Add Family Member</h2>
        <button class="btn btn-icon btn-sm" onclick="closeMemberModal()" aria-label="Close">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
          </svg>
        </button>
      </div>

      <div class="modal-body">
        <input type="hidden" id="memberId">
        <div class="form-row">
          <div class="form-group"><label>First Name</label><input type="text" id="firstName" placeholder="e.g. John"></div>
          <div class="form-group"><label>Last Name</label><input type="text" id="lastName" placeholder="e.g. Smith"></div>
        </div>
        <div class="form-row">
          <div class="form-group"><label>Maiden Name</label><input type="text" id="maidenName" placeholder="Optional"></div>
          <div class="form-group">
            <label>Gender</label>
            <select id="gender">
              <option value="male">Male</option>
              <option value="female">Female</option>
              <option value="unknown">Other</option>
            </select>
          </div>
        </div>
        <div class="form-row">
          <div class="form-group"><label>Birth Date</label><input type="date" id="birthDate"></div>
          <div class="form-group"><label>Death Date</label><input type="date" id="deathDate"></div>
        </div>
        <div class="form-group">
          <label>Generation (override)</label>
          <select id="generationOverride">
            <option value="">Auto</option>
            <option value="0">Top (Oldest)</option>
            <option value="1">Row 2</option>
            <option value="2">Row 3</option>
            <option value="3">Row 4</option>
            <option value="4">Row 5</option>
            <option value="5">Row 6</option>
          </select>
          <div class="help-text">Force this person to render in a specific generation row.</div>
        </div>
        <div class="photo-preview-row">
          <div class="form-group">
            <label>Photo URL</label>
            <input type="url" id="photoUrl" placeholder="Immich / pCloud / direct URL" oninput="updatePhotoPreview()">
            <div class="help-text">Immich shared links, pCloud public links, or direct image URLs</div>
          </div>
          <div class="photo-preview" id="photoPreview"><span class="preview-placeholder">No photo</span></div>
        </div>

        <div class="form-group"><label>Bio / Notes</label><textarea id="bio" placeholder="A short biography..."></textarea></div>
      </div>

      <div class="modal-footer">
        <button class="btn" onclick="closeMemberModal()">Cancel</button>
        <button class="btn btn-primary" onclick="saveMember()">Save</button>
      </div>
    </div>
  </div>

  <!-- Relationship Modal -->
  <div class="modal-overlay" id="relModal">
    <div class="modal">
      <div class="modal-header">
        <h2>Add Relationship</h2>
        <button class="btn btn-icon btn-sm" onclick="closeRelModal()" aria-label="Close">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
          </svg>
        </button>
      </div>

      <div class="modal-body">
        <div class="form-group">
          <label>Relationship Type</label>
          <select id="relType" onchange="updateRelLabels()">
            <option value="parent-child">Parent â†’ Child</option>
            <option value="spouse">Spouse / Partner</option>
          </select>
        </div>
        <div class="form-group"><label id="relPerson1Label">Parent</label><select id="relPerson1"></select></div>
        <div class="form-group"><label id="relPerson2Label">Child</label><select id="relPerson2"></select></div>
      </div>

      <div class="modal-footer">
        <button class="btn" onclick="closeRelModal()">Cancel</button>
        <button class="btn btn-primary" onclick="saveRelationship()">Add Relationship</button>
      </div>
    </div>
  </div>

  <!-- Settings Modal -->
  <div class="modal-overlay" id="settingsModal">
    <div class="modal">
      <div class="modal-header">
        <h2>Settings</h2>
        <button class="btn btn-icon btn-sm" onclick="closeSettings()" aria-label="Close">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
          </svg>
        </button>
      </div>

      <div class="modal-body">
        <div class="form-group"><label>Tree Title</label><input type="text" id="settingsTitle" placeholder="Our Family Tree"></div>
        <div class="form-group"><label>Subtitle</label><input type="text" id="settingsSubtitle" placeholder="Description..."></div>
        <div class="form-group">
          <div class="help-text">
            Tip: You can <b>drag a person (their whole couple/unit)</b> left/right to reduce line crossings. This is saved in your browser.
          </div>
        </div>
      </div>

      <div class="modal-footer">
        <button class="btn" onclick="closeSettings()">Cancel</button>
        <button class="btn btn-primary" onclick="saveSettings()">Save</button>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <script>
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  STATE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let familyData = { members:[], relationships:[], settings:{ title:'Our Family Tree', subtitle:'' } };
    let selectedMemberId = null;

    // manual horizontal offsets per unitKey (personId or "a|b" for couples)
    let unitOffsets = {}; // { [unitKey]: { dx:number } }

    // drag state
    let drag = {
      active:false,
      unitKey:null,
      pointerId:null,
      startClientX:0,
      startDx:0,
      moved:false,
      justEnded:false,
      justEndedTimer:null,
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  API
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    async function api(method, path, body) {
      const opts = { method, headers: { "Content-Type": "application/json" } };
      if (body !== undefined) opts.body = JSON.stringify(body);

      const res = await fetch("/api" + path, opts);

      if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error(`${method} /api${path} failed: ${res.status} ${res.statusText} ${txt}`.slice(0, 400));
      }

      if (res.status === 204) return null;

      const ct = res.headers.get("content-type") || "";
      if (!ct.includes("application/json")) {
        const txt = await res.text().catch(() => "");
        return txt ? { raw: txt } : null;
      }
      return res.json();
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  LOCAL STORAGE (layout only)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const OFFSETS_KEY = "familyTree.unitOffsets.v1";

    function loadOffsetsFromStorage() {
      try {
        const raw = localStorage.getItem(OFFSETS_KEY);
        unitOffsets = raw ? JSON.parse(raw) : {};
        if (!unitOffsets || typeof unitOffsets !== "object") unitOffsets = {};
      } catch {
        unitOffsets = {};
      }
    }

    function saveOffsetsToStorage() {
      try {
        localStorage.setItem(OFFSETS_KEY, JSON.stringify(unitOffsets));
      } catch {}
    }

    function resetLayout() {
      closeMenu();
      if (!confirm("Reset all manual left/right adjustments?")) return;
      unitOffsets = {};
      saveOffsetsToStorage();
      renderTree();
      showToast("Manual layout reset");
    }

    async function loadFamily() {
      try {
        familyData = await api("GET", "/family");
        if (!familyData || typeof familyData !== "object") throw new Error("Invalid /family response");
        if (!Array.isArray(familyData.members)) familyData.members = [];
        if (!Array.isArray(familyData.relationships)) familyData.relationships = [];
        if (!familyData.settings) familyData.settings = { title: "Our Family Tree", subtitle: "" };

        loadOffsetsFromStorage();
        renderTree();
        updateTitle();
      } catch (e) {
        console.error(e);
        showToast("Failed to load data (check console)");
        familyData = { members: [], relationships: [], settings: { title: "Our Family Tree", subtitle: "" } };
        loadOffsetsFromStorage();
        renderTree();
        updateTitle();
      }
    }

    function updateTitle() {
      document.getElementById('treeTitle').textContent = familyData.settings.title || 'Our Family Tree';
      document.getElementById('treeSubtitle').textContent =
        familyData.settings.subtitle ||
        (familyData.members.length===0 ? 'Click "Add Person" to start building your family tree' : '');
      document.title = familyData.settings.title || 'Our Family Tree';
    }

    function showToast(msg) {
      const t = document.getElementById('toast');
      t.textContent = String(msg || "");
      t.classList.add('show');
      setTimeout(() => t.classList.remove('show'), 2500);
    }

    function toggleMenu() {
      document.getElementById('dropdownMenu').classList.toggle('show');
    }
    function closeMenu() {
      document.getElementById('dropdownMenu').classList.remove('show');
    }
    document.addEventListener('click', e => {
      if (!e.target.closest('.dropdown')) closeMenu();
    });

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  PHOTO
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function resolvePhotoUrl(url) {
      return url ? '/api/photo?url=' + encodeURIComponent(url) : '';
    }
    function updatePhotoPreview() {
      const url = document.getElementById('photoUrl').value.trim();
      const p = document.getElementById('photoPreview');
      p.innerHTML = url
        ? `<img src="${resolvePhotoUrl(url)}" onerror="this.parentElement.innerHTML='<span class=\\'preview-placeholder\\'>Error</span>'">`
        : '<span class="preview-placeholder">No photo</span>';
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  MEMBER CRUD
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function openAddMember() {
      document.getElementById('generationOverride').value = '';
      document.getElementById('memberModalTitle').textContent = 'Add Family Member';
      ['memberId','firstName','lastName','maidenName','birthDate','deathDate','photoUrl','bio'].forEach(id => {
        document.getElementById(id).value = '';
      });
      document.getElementById('gender').value = 'male';
      updatePhotoPreview();
      document.getElementById('memberModal').classList.add('active');
      setTimeout(() => document.getElementById('firstName').focus(), 100);
      closeMenu();
    }

    function openEditMember(id) {
      const m = familyData.members.find(x => x.id === id);
      if (!m) return;

      document.getElementById('generationOverride').value =
        (m.generationOverride === 0 || m.generationOverride) ? String(m.generationOverride) : '';

      document.getElementById('memberModalTitle').textContent = 'Edit ' + (m.firstName || '');
      document.getElementById('memberId').value = m.id;
      ['firstName','lastName','maidenName','gender','birthDate','deathDate','photoUrl','bio'].forEach(f => {
        document.getElementById(f).value = m[f] || '';
      });
      updatePhotoPreview();
      document.getElementById('memberModal').classList.add('active');
      closeMenu();
    }

    function closeMemberModal() {
      document.getElementById('memberModal').classList.remove('active');
    }

    async function saveMember() {
      const genRaw = document.getElementById('generationOverride').value;
      const generationOverride = genRaw === '' ? null : Number(genRaw);

      const id = document.getElementById('memberId').value;
      const d = {
        firstName: document.getElementById('firstName').value.trim(),
        lastName: document.getElementById('lastName').value.trim(),
        maidenName: document.getElementById('maidenName').value.trim(),
        gender: document.getElementById('gender').value,
        birthDate: document.getElementById('birthDate').value,
        deathDate: document.getElementById('deathDate').value,
        photoUrl: document.getElementById('photoUrl').value.trim(),
        bio: document.getElementById('bio').value.trim(),
        generationOverride
      };

      if (!d.firstName) { showToast('First name required'); return; }

      try {
        if (id) {
          await api('PUT', '/members/' + id, d);
          showToast(d.firstName + ' updated');
        } else {
          await api('POST', '/members', d);
          showToast(d.firstName + ' added');
        }
        closeMemberModal();
        await loadFamily();
        if (id && selectedMemberId === id) showDetail(id);
      } catch (e) {
        console.error(e);
        showToast('Save failed (check console)');
      }
    }

    async function deleteMember(id) {
      const m = familyData.members.find(x => x.id === id);
      if (!m || !confirm(`Remove ${m.firstName || ''} ${m.lastName || ''}?`)) return;

      try {
        await api('DELETE', '/members/' + id);
        closeDetailPanel();
        showToast((m.firstName || 'Person') + ' removed');
        await loadFamily();
      } catch (e) {
        console.error(e);
        showToast('Delete failed (check console)');
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  RELATIONSHIP CRUD
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function openRelationshipModal() {
      if (familyData.members.length < 2) { showToast('Add at least 2 people first'); return; }

      const o = familyData.members
        .map(m => `<option value="${m.id}">${escapeHtml(m.firstName || '')} ${escapeHtml(m.lastName || '')}</option>`)
        .join('');

      document.getElementById('relPerson1').innerHTML = o;
      document.getElementById('relPerson2').innerHTML = o;

      if (familyData.members.length > 1) document.getElementById('relPerson2').selectedIndex = 1;

      updateRelLabels();
      document.getElementById('relModal').classList.add('active');
      closeMenu();
    }

    function updateRelLabels() {
      const t = document.getElementById('relType').value;
      document.getElementById('relPerson1Label').textContent = t === 'parent-child' ? 'Parent' : 'Person 1';
      document.getElementById('relPerson2Label').textContent = t === 'parent-child' ? 'Child' : 'Person 2';
    }

    function closeRelModal() {
      document.getElementById('relModal').classList.remove('active');
    }

    async function saveRelationship() {
      const p1 = document.getElementById('relPerson1').value;
      const p2 = document.getElementById('relPerson2').value;
      if (p1 === p2) { showToast('Select two different people'); return; }

      try {
        const r = await api('POST', '/relationships', { type: document.getElementById('relType').value, person1: p1, person2: p2 });
        if (r && r.error) { showToast(r.error); return; }
        closeRelModal();
        showToast('Relationship added');
        await loadFamily();
      } catch (e) {
        console.error(e);
        showToast('Add relation failed (check console)');
      }
    }

    async function deleteRelationship(rid) {
      try {
        await api('DELETE', '/relationships/' + rid);
        showToast('Removed');
        await loadFamily();
        if (selectedMemberId) showDetail(selectedMemberId);
      } catch (e) {
        console.error(e);
        showToast('Remove relation failed (check console)');
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  SETTINGS / EXPORT / IMPORT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function openSettings() {
      document.getElementById('settingsTitle').value = familyData.settings.title || '';
      document.getElementById('settingsSubtitle').value = familyData.settings.subtitle || '';
      document.getElementById('settingsModal').classList.add('active');
      closeMenu();
    }

    function closeSettings() {
      document.getElementById('settingsModal').classList.remove('active');
    }

    async function saveSettings() {
      const s = {
        title: document.getElementById('settingsTitle').value.trim() || 'Our Family Tree',
        subtitle: document.getElementById('settingsSubtitle').value.trim()
      };

      try {
        await api('PUT', '/settings', s);
        familyData.settings = s;
        updateTitle();
        closeSettings();
        showToast('Saved');
      } catch (e) {
        console.error(e);
        showToast('Save settings failed (check console)');
      }
    }

    function exportData() {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(new Blob([JSON.stringify(familyData, null, 2)], { type:'application/json' }));
      a.download = 'family-tree-export.json';
      a.click();
      closeMenu();
      showToast('Exported');
    }

    async function importData(e) {
      const f = e.target.files[0];
      if (!f) return;

      try {
        const d = JSON.parse(await f.text());
        if (!d.members || !d.relationships) throw new Error("Invalid format");
        await api('POST', '/import', d);
        showToast('Imported');
        await loadFamily();
      } catch (err) {
        console.error(err);
        showToast('Invalid file');
      } finally {
        e.target.value = '';
        closeMenu();
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  DETAIL PANEL
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function showDetailWrapper(id) {
      // prevent accidental click after a drag
      if (drag.justEnded) return;
      showDetail(id);
    }

    function showDetail(id) {
      selectedMemberId = id;
      const m = familyData.members.find(x => x.id === id);
      if (!m) return;

      const ini = (m.firstName?.[0] || '') + (m.lastName?.[0] || '');
      const ph = m.photoUrl
        ? `<img src="${resolvePhotoUrl(m.photoUrl)}" onerror="this.style.display='none';this.nextElementSibling.style.display='flex'">`
        : '';
      const iH = `<span class="initials" ${m.photoUrl ? 'style="display:none"' : ''}>${escapeHtml(ini)}</span>`;

      const sp = familyData.relationships
        .filter(r => r.type === 'spouse' && (r.person1 === id || r.person2 === id))
        .map(r => ({ rel:r, member: familyData.members.find(x => x.id === (r.person1 === id ? r.person2 : r.person1)) }))
        .filter(x => x.member);

      const pa = familyData.relationships
        .filter(r => r.type === 'parent-child' && r.person2 === id)
        .map(r => ({ rel:r, member: familyData.members.find(x => x.id === r.person1) }))
        .filter(x => x.member);

      const ch = familyData.relationships
        .filter(r => r.type === 'parent-child' && r.person1 === id)
        .map(r => ({ rel:r, member: familyData.members.find(x => x.id === r.person2) }))
        .filter(x => x.member);

      const si = findSiblings(id);

      function relList(label, items) {
        if (!items.length) return '';
        return `<div class="detail-relations">
          <h4>${escapeHtml(label)}</h4>
          ${items.map(x => {
            const i = (x.member.firstName?.[0] || '') + (x.member.lastName?.[0] || '');
            const p = x.member.photoUrl
              ? `<img src="${resolvePhotoUrl(x.member.photoUrl)}" onerror="this.style.display='none'">`
              : `<span class="initials">${escapeHtml(i)}</span>`;
            const delBtn = x.rel.id !== 'sibling'
              ? `<button class="btn btn-sm btn-danger" style="margin-left:auto;padding:2px 6px;font-size:0.7rem"
                   onclick="event.stopPropagation();deleteRelationship('${x.rel.id}')">âœ•</button>`
              : '';
            return `<div class="detail-rel-item" onclick="showDetail('${x.member.id}')">
              <div class="mini-photo">${p}</div>
              <span>${escapeHtml(x.member.firstName || '')} ${escapeHtml(x.member.lastName || '')}</span>
              ${delBtn}
            </div>`;
          }).join('')}
        </div>`;
      }

      const dates = [];
      if (m.birthDate) dates.push('b. ' + formatDate(m.birthDate));
      if (m.deathDate) dates.push('d. ' + formatDate(m.deathDate));

      document.getElementById('detailContent').innerHTML = `
        <div class="detail-photo ${escapeHtml(m.gender || '')}">${ph}${iH}</div>
        <div class="detail-name">${escapeHtml(m.firstName || '')} ${escapeHtml(m.lastName || '')}</div>
        ${m.maidenName ? `<div class="detail-maiden">nÃ©e ${escapeHtml(m.maidenName)}</div>` : ''}
        ${dates.length ? `<div class="detail-dates">${escapeHtml(dates.join(' â€” '))}</div>` : ''}
        ${m.bio ? `<div class="detail-bio">${escapeHtml(m.bio)}</div>` : ''}
        ${relList('Spouse / Partner', sp)}
        ${relList('Parents', pa)}
        ${relList('Children', ch)}
        ${relList('Siblings', si)}
        <div class="detail-actions">
          <button class="btn" onclick="openEditMember('${m.id}')">âœï¸ Edit</button>
          <button class="btn btn-danger" onclick="deleteMember('${m.id}')">ğŸ—‘ Delete</button>
        </div>
      `;
      document.getElementById('detailPanel').classList.add('open');
    }

    function closeDetailPanel() {
      document.getElementById('detailPanel').classList.remove('open');
      selectedMemberId = null;
    }

    function findSiblings(id) {
      const pids = familyData.relationships
        .filter(r => r.type === 'parent-child' && r.person2 === id)
        .map(r => r.person1);

      if (!pids.length) return [];

      const s = new Set();
      pids.forEach(pid => {
        familyData.relationships
          .filter(r => r.type === 'parent-child' && r.person1 === pid && r.person2 !== id)
          .forEach(r => s.add(r.person2));
      });

      return [...s]
        .map(sid => ({ rel:{ id:'sibling' }, member: familyData.members.find(x => x.id === sid) }))
        .filter(x => x.member);
    }

    function formatDate(d) {
      return d ? new Date(d + 'T00:00:00').toLocaleDateString('en-US', { year:'numeric', month:'short', day:'numeric' }) : '';
    }

    function escapeHtml(s) {
      return String(s ?? '')
        .replaceAll('&','&amp;')
        .replaceAll('<','&lt;')
        .replaceAll('>','&gt;')
        .replaceAll('"','&quot;')
        .replaceAll("'","&#39;");
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  DRAG: move a unit left/right
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function onNodePointerDown(e, unitKey) {
      // only left click or touch/pen; ignore right click
      if (e.button !== undefined && e.button !== 0) return;

      drag.active = true;
      drag.unitKey = unitKey;
      drag.pointerId = e.pointerId ?? null;
      drag.startClientX = e.clientX;
      drag.startDx = (unitOffsets[unitKey]?.dx || 0);
      drag.moved = false;

      if (drag.justEndedTimer) clearTimeout(drag.justEndedTimer);
      drag.justEnded = false;

      document.body.classList.add("dragging");

      // capture pointer so we keep receiving move events
      try { e.currentTarget.setPointerCapture(e.pointerId); } catch {}

      e.preventDefault();
      e.stopPropagation();
    }

    function onNodePointerMove(e) {
      if (!drag.active) return;
      if (drag.pointerId !== null && e.pointerId !== drag.pointerId) return;

      const delta = e.clientX - drag.startClientX;
      if (Math.abs(delta) > 3) drag.moved = true;

      const newDx = drag.startDx + delta;

      // optional: clamp so things don't fly away
      const CLAMP = 600;
      const clamped = Math.max(-CLAMP, Math.min(CLAMP, newDx));

      unitOffsets[drag.unitKey] = { dx: clamped };
      renderTree();
      e.preventDefault();
    }

    function onNodePointerUp(e) {
      if (!drag.active) return;
      if (drag.pointerId !== null && e.pointerId !== drag.pointerId) return;

      drag.active = false;
      document.body.classList.remove("dragging");

      // save only if actually moved
      if (drag.moved) {
        saveOffsetsToStorage();
        showToast("Layout adjusted (saved in browser)");
      }

      // prevent click firing immediately after drag
      drag.justEnded = drag.moved;
      drag.justEndedTimer = setTimeout(() => { drag.justEnded = false; }, 200);

      drag.unitKey = null;
      drag.pointerId = null;
      drag.moved = false;

      e.preventDefault();
      e.stopPropagation();
    }

    // bind global pointer listeners once
    window.addEventListener("pointermove", onNodePointerMove, { passive:false });
    window.addEventListener("pointerup", onNodePointerUp, { passive:false });
    window.addEventListener("pointercancel", onNodePointerUp, { passive:false });

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  TREE LAYOUT ENGINE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const CARD_W = 110;     // card width
    const CARD_H = 130;     // card height (photo + name + dates)
    const COUPLE_GAP = 16;  // gap between spouses
    const SIBLING_GAP = 40; // gap between sibling family units
    const GEN_GAP = 70;     // vertical gap between generations
    const PADDING = 40;

    function renderTree() {
      const canvas = document.getElementById('treeCanvas');

      if (familyData.members.length === 0) {
        canvas.innerHTML = `
          <div class="empty-state">
            <div class="tree-icon">ğŸŒ³</div>
            <h2>Start Your Family Tree</h2>
            <p>Add your first family member to begin.</p>
            <button class="btn btn-primary" onclick="openAddMember()">+ Add First Person</button>
          </div>`;
        canvas.style.width = 'auto';
        canvas.style.height = 'auto';
        return;
      }

      const { nodes, lines, width, height, genLabels } = layoutTree();

      let html = `<svg id="treeSvg" width="${width}" height="${height}" style="width:${width}px;height:${height}px;">`;
      lines.forEach(l => { html += `<line x1="${l.x1}" y1="${l.y1}" x2="${l.x2}" y2="${l.y2}"/>`; });
      html += '</svg>';

      nodes.forEach(n => {
        const m = familyData.members.find(x => x.id === n.id);
        if (!m) return;
        html += makeNodeHtml(m, n.x, n.y, n.unitKey);
      });

      genLabels.forEach(gl => {
        html += `<div class="gen-label-abs" style="left:${gl.x}px;top:${gl.y}px;">${escapeHtml(gl.text)}</div>`;
      });

      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      canvas.style.position = 'relative';
      canvas.innerHTML = html;
    }

    function makeNodeHtml(m, x, y, unitKey) {
      const ini = (m.firstName?.[0] || '') + (m.lastName?.[0] || '');
      const ph = m.photoUrl
        ? `<img src="${resolvePhotoUrl(m.photoUrl)}" loading="lazy" onerror="this.style.display='none';this.nextElementSibling.style.display='flex'">`
        : '';
      const iS = `<span class="initials" ${m.photoUrl ? 'style="display:none"' : ''}>${escapeHtml(ini)}</span>`;

      const yrs = [];
      if (m.birthDate) yrs.push(new Date(m.birthDate + 'T00:00:00').getFullYear());
      if (m.deathDate) yrs.push(new Date(m.deathDate + 'T00:00:00').getFullYear());

      return `<div class="tree-node drag-hint"
        style="left:${x}px;top:${y}px;width:${CARD_W}px;"
        onclick="showDetailWrapper('${m.id}')"
        onpointerdown="onNodePointerDown(event, '${escapeHtml(unitKey)}')"
        title="Drag left/right to adjust layout">
        <div class="photo ${escapeHtml(m.gender || '')}">${ph}${iS}</div>
        <div class="name">${escapeHtml(m.firstName || '')} ${escapeHtml(m.lastName || '')}</div>
        ${m.maidenName ? `<div class="maiden">nÃ©e ${escapeHtml(m.maidenName)}</div>` : ''}
        ${yrs.length ? `<div class="dates">${escapeHtml(yrs.join(' â€“ '))}</div>` : ''}
      </div>`;
    }

    function layoutTree() {
      const rels = familyData.relationships;
      const members = familyData.members;
      const pcRels = rels.filter(r => r.type === 'parent-child');
      const spRels = rels.filter(r => r.type === 'spouse');

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // GENERATION ASSIGNMENT (with manual overrides)
      //  - generationOverride anchors a person to a row
      //  - spouses share row (propagate anchor across spouse component)
      //  - parent-child enforces child >= parent + 1
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const depth = {};
      members.forEach(m => depth[m.id] = 0);

      // 1) anchors
      const anchor = {};
      members.forEach(m => {
        if (m.generationOverride === 0 || m.generationOverride) {
          const v = Number(m.generationOverride);
          if (!Number.isNaN(v) && v >= 0) anchor[m.id] = v;
        }
      });

      // 2) spouse adjacency
      const spouseAdj = {};
      spRels.forEach(r => {
        (spouseAdj[r.person1] = spouseAdj[r.person1] || []).push(r.person2);
        (spouseAdj[r.person2] = spouseAdj[r.person2] || []).push(r.person1);
      });

      // 3) propagate anchors through spouse components (component anchor = max)
      const visited = new Set();
      Object.keys(anchor).forEach(startId => {
        if (visited.has(startId)) return;
        const q = [startId];
        const comp = [];
        visited.add(startId);

        while (q.length) {
          const cur = q.shift();
          comp.push(cur);
          (spouseAdj[cur] || []).forEach(nxt => {
            if (!visited.has(nxt)) {
              visited.add(nxt);
              q.push(nxt);
            }
          });
        }

        const anchoredVals = comp.map(id => anchor[id]).filter(v => v !== undefined);
        if (!anchoredVals.length) return;
        const compAnchor = Math.max(...anchoredVals);
        comp.forEach(id => { anchor[id] = compAnchor; });
      });

      // 4) init depth with anchors
      Object.keys(anchor).forEach(id => { depth[id] = Math.max(depth[id], anchor[id]); });

      const MAX_ITERS = members.length * 8;

      for (let i = 0; i < MAX_ITERS; i++) {
        let changed = false;

        // spouses same generation: pull up to max (never down)
        spRels.forEach(r => {
          const a = r.person1, b = r.person2;
          const mx = Math.max(depth[a] ?? 0, depth[b] ?? 0);
          if (depth[a] !== mx) { depth[a] = mx; changed = true; }
          if (depth[b] !== mx) { depth[b] = mx; changed = true; }
        });

        // honor anchors
        Object.entries(anchor).forEach(([id, ad]) => {
          if ((depth[id] ?? 0) < ad) { depth[id] = ad; changed = true; }
        });

        // parent-child
        pcRels.forEach(r => {
          const p = r.person1, c = r.person2;
          const want = (depth[p] ?? 0) + 1;
          if ((depth[c] ?? 0) < want) { depth[c] = want; changed = true; }
        });

        if (!changed) break;
      }

      // normalize min depth to 0
      const minD = Math.min(...Object.values(depth));
      Object.keys(depth).forEach(id => depth[id] -= minD);
      const maxD = Math.max(...Object.values(depth));

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // BUILD COUPLE/SINGLE UNITS PER GENERATION
      //  - ensure female on the RIGHT (male left), when gender known
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const spousesOf = {};
      spRels.forEach(r => {
        (spousesOf[r.person1] = spousesOf[r.person1] || []).push(r.person2);
        (spousesOf[r.person2] = spousesOf[r.person2] || []).push(r.person1);
      });

      const personToUnitKey = {};
      const unitKeyToMembers = {};
      const used = new Set();

      for (let d = 0; d <= maxD; d++) {
        const gm = members.filter(m => depth[m.id] === d);
        gm.forEach(m => {
          if (used.has(m.id)) return;

          const spouseId = (spousesOf[m.id] || []).find(sid => !used.has(sid) && depth[sid] === d);

          if (spouseId) {
            const m1 = members.find(x => x.id === m.id);
            const m2 = members.find(x => x.id === spouseId);

            let leftId, rightId;
            if (m1?.gender === 'male' && m2?.gender === 'female') {
              leftId = m1.id; rightId = m2.id;
            } else if (m1?.gender === 'female' && m2?.gender === 'male') {
              leftId = m2.id; rightId = m1.id;
            } else {
              [leftId, rightId] = [m.id, spouseId].sort();
            }

            const key = `${leftId}|${rightId}`;
            used.add(leftId); used.add(rightId);
            unitKeyToMembers[key] = [leftId, rightId];
            personToUnitKey[leftId] = key;
            personToUnitKey[rightId] = key;
          } else {
            const key = m.id;
            used.add(m.id);
            unitKeyToMembers[key] = [m.id];
            personToUnitKey[m.id] = key;
          }
        });
      }

      // units by generation
      const unitsByGen = Array.from({ length: maxD + 1 }, () => []);
      Object.entries(unitKeyToMembers).forEach(([key, ids]) => {
        const d = depth[ids[0]] ?? 0;
        unitsByGen[d].push(key);
      });

      // ordering: roots -> children
      const childrenOf = {};
      pcRels.forEach(r => {
        (childrenOf[r.person1] = childrenOf[r.person1] || []).push(r.person2);
      });

      const unitChildren = {};
      const unitParents = {};
      Object.keys(unitKeyToMembers).forEach(k => { unitChildren[k] = new Set(); unitParents[k] = new Set(); });

      pcRels.forEach(r => {
        const pu = personToUnitKey[r.person1];
        const cu = personToUnitKey[r.person2];
        if (!pu || !cu || pu === cu) return;
        unitChildren[pu].add(cu);
        unitParents[cu].add(pu);
      });

      const orderedUnitsByGen = Array.from({ length: maxD + 1 }, () => []);

      const rootUnits = unitsByGen[0]
        .filter(u => unitParents[u].size === 0)
        .sort((u1, u2) => {
          const a1 = unitKeyToMembers[u1][0], a2 = unitKeyToMembers[u2][0];
          const mm1 = members.find(x => x.id === a1), mm2 = members.find(x => x.id === a2);
          const s1 = `${mm1?.lastName||''} ${mm1?.firstName||''}`.toLowerCase();
          const s2 = `${mm2?.lastName||''} ${mm2?.firstName||''}`.toLowerCase();
          return s1.localeCompare(s2);
        });

      const seenUnit = new Set();
      rootUnits.forEach(u => { orderedUnitsByGen[0].push(u); seenUnit.add(u); });
      unitsByGen[0].forEach(u => { if (!seenUnit.has(u)) { orderedUnitsByGen[0].push(u); seenUnit.add(u); } });

      for (let d = 0; d < maxD; d++) {
        unitsByGen[d].forEach(u => { if (!orderedUnitsByGen[d].includes(u)) orderedUnitsByGen[d].push(u); });

        const next = [];
        orderedUnitsByGen[d].forEach(u => {
          [...unitChildren[u]].forEach(cu => {
            if ((depth[unitKeyToMembers[cu][0]] ?? 0) === d + 1 && !next.includes(cu)) next.push(cu);
          });
        });
        unitsByGen[d + 1].forEach(u => { if (!next.includes(u)) next.push(u); });
        orderedUnitsByGen[d + 1] = next;
      }

      const gens = [];
      for (let d = 0; d <= maxD; d++) {
        const orderedKeys = orderedUnitsByGen[d].length ? orderedUnitsByGen[d] : unitsByGen[d];
        const units = orderedKeys
          .filter(k => (unitKeyToMembers[k] || []).length)
          .map(k => unitKeyToMembers[k].map(id => members.find(m => m.id === id)).filter(Boolean));
        if (units.length) gens.push({ depth: d, unitKeys: orderedKeys, units });
      }

      // â”€â”€ Positions â”€â”€
      const nodes = [];
      const lines = [];

      // compute widest row
      let totalW = 0;
      gens.forEach(gen => {
        let genW = 0;
        gen.units.forEach(unit => {
          genW += (unit.length === 2 ? 2*CARD_W + COUPLE_GAP : CARD_W) + SIBLING_GAP;
        });
        genW -= SIBLING_GAP;
        totalW = Math.max(totalW, genW);
      });

      const canvasW = totalW + PADDING * 2;

      // store unit centers by unitKey
      const unitPosByKey = {}; // unitKey -> { cx, cy, unitW }

      gens.forEach((gen, gi) => {
        const y = PADDING + gi * (CARD_H + GEN_GAP);

        let genW = 0;
        gen.units.forEach(unit => { genW += (unit.length === 2 ? 2*CARD_W + COUPLE_GAP : CARD_W) + SIBLING_GAP; });
        genW -= SIBLING_GAP;

        let x = (canvasW - genW) / 2;

        gen.units.forEach((unit, ui) => {
          const unitKey = gen.unitKeys[ui]; // matches the ordering we used
          const unitW = unit.length === 2 ? 2*CARD_W + COUPLE_GAP : CARD_W;

          const dx = unitOffsets[unitKey]?.dx || 0;
          const cx = x + unitW / 2 + dx;

          // derive left edge from shifted center
          const left = cx - unitW / 2;

          if (unit.length === 2) {
            const leftId = unit[0].id;
            const rightId = unit[1].id;

            const x1 = left;
            const x2 = left + CARD_W + COUPLE_GAP;

            nodes.push({ id: leftId, x: x1, y, unitKey });
            nodes.push({ id: rightId, x: x2, y, unitKey });

            // spouse line
            const lineY = y + 38;
            lines.push({ x1: x1 + CARD_W/2, y1: lineY, x2: x2 + CARD_W/2, y2: lineY });

            unitPosByKey[unitKey] = { cx: cx, cy: y, unitW, memberIds: [leftId, rightId], gi, ui };
          } else {
            nodes.push({ id: unit[0].id, x: left, y, unitKey });
            unitPosByKey[unitKey] = { cx: cx, cy: y, unitW, memberIds: [unit[0].id], gi, ui };
          }

          x += unitW + SIBLING_GAP;
        });
      });

      // â”€â”€ Parent-child lines â”€â”€
      gens.forEach((gen, gi) => {
        gen.units.forEach((unit, ui) => {
          const unitKey = gen.unitKeys[ui];
          const parentIds = unit.map(m => m.id);

          const allChildIds = new Set();
          parentIds.forEach(pid => (childrenOf[pid] || []).forEach(cid => allChildIds.add(cid)));
          if (!allChildIds.size) return;

          const parentPos = unitPosByKey[unitKey];
          if (!parentPos) return;

          const parentBottomY = parentPos.cy + CARD_H - 20;
          const parentCx = parentPos.cx;

          const childNodes = [...allChildIds].map(cid => nodes.find(n => n.id === cid)).filter(Boolean);
          if (!childNodes.length) return;

          // baseline midpoint + lane jitter to reduce overlaps
          const childTopY = Math.min(...childNodes.map(n => n.y));
          const midBase = parentBottomY + (childTopY - parentBottomY) / 2;

          const lane = ui % 7;     // more lanes reduces collisions
          const LANE_GAP = 10;
          const midY = midBase + lane * LANE_GAP;

          // drop from parent to bus midY
          lines.push({ x1: parentCx, y1: parentBottomY, x2: parentCx, y2: midY });

          const childCxs = childNodes.map(n => n.x + CARD_W / 2).sort((a,b) => a - b);

          if (childCxs.length === 1) {
            lines.push({ x1: parentCx, y1: midY, x2: childCxs[0], y2: midY });
            lines.push({ x1: childCxs[0], y1: midY, x2: childCxs[0], y2: childTopY });
          } else {
            // horizontal bus
            lines.push({ x1: childCxs[0], y1: midY, x2: childCxs[childCxs.length-1], y2: midY });

            const minCx = childCxs[0];
            const maxCx = childCxs[childCxs.length - 1];
            const joinX = Math.min(Math.max(parentCx, minCx), maxCx);

            // connect parent to bus at joinX (avoids long diagonal-ish overlaps)
            lines.push({ x1: parentCx, y1: midY, x2: joinX, y2: midY });

            // drops to children
            childCxs.forEach(cx => lines.push({ x1: cx, y1: midY, x2: cx, y2: childTopY }));
          }
        });
      });

      // â”€â”€ Generation labels â”€â”€
      const genLabels = [];
      const n = gens.length;
      gens.forEach((gen, gi) => {
        const fromBottom = n - 1 - gi;
        let label = '';
        if (n > 1) {
          if (fromBottom === 0) label = 'Children';
          else if (fromBottom === 1) label = 'Parents';
          else if (fromBottom === 2) label = 'Grandparents';
          else label = 'Great-'.repeat(fromBottom - 2) + 'Grandparents';
        }
        if (label) {
          const y = PADDING + gi * (CARD_H + GEN_GAP) - 16;
          genLabels.push({ text: label, x: canvasW / 2 - label.length * 3.5, y });
        }
      });

      const totalH = PADDING * 2 + gens.length * CARD_H + (gens.length - 1) * GEN_GAP;
      return { nodes, lines, width: canvasW, height: totalH, genLabels };
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  SAMPLE DATA
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    async function loadSampleData() {
      closeMenu();
      if (familyData.members.length > 0 && !confirm('Replace current tree with sample data?')) return;

      const s = {
        settings:{ title:'Our Family Tree', subtitle:'The Anderson & Brown Family' },
        members:[
          {id:'gf1',firstName:'Betty',lastName:'Brown',gender:'female',birthDate:'1945-03-12',photoUrl:'',bio:'Matriarch'},
          {id:'gm1',firstName:'Ron',lastName:'Anderson',gender:'male',birthDate:'1943-07-20',photoUrl:'',bio:'Patriarch'},
          {id:'p2',firstName:'Jace',lastName:'Anderson',gender:'male',birthDate:'1970-02-14',photoUrl:''},
          {id:'p3',firstName:'Alyssa',lastName:'Anderson',maidenName:'Lewis',gender:'female',birthDate:'1972-09-30'},
          {id:'p4',firstName:'Aaron',lastName:'Lewis',gender:'male',birthDate:'1940-01-18',deathDate:'2015-12-01'},
          {id:'c1',firstName:'Jessie',lastName:'Anderson',gender:'female',birthDate:'1995-06-22'},
          {id:'c2',firstName:'Evan',lastName:'Anderson',gender:'male',birthDate:'1997-03-10'},
          {id:'c3',firstName:'Ginger',lastName:'Anderson',gender:'female',birthDate:'2000-12-25'},
          {id:'c4',firstName:'Christian',lastName:'Lewis',gender:'male',birthDate:'1998-08-15'},
          {id:'c5',firstName:'Maria',lastName:'Lewis',gender:'female',birthDate:'2001-04-02'}
        ],
        relationships:[
          {id:'r1',type:'spouse',person1:'gf1',person2:'gm1'},
          {id:'r3',type:'parent-child',person1:'gf1',person2:'p2'},{id:'r4',type:'parent-child',person1:'gm1',person2:'p2'},
          {id:'r5',type:'parent-child',person1:'gm1',person2:'p3'},{id:'r6',type:'parent-child',person1:'gf1',person2:'p3'},
          {id:'r7',type:'spouse',person1:'p3',person2:'p4'},
          {id:'r8',type:'parent-child',person1:'p2',person2:'c1'},{id:'r9',type:'parent-child',person1:'p2',person2:'c2'},
          {id:'r10',type:'parent-child',person1:'p2',person2:'c3'},
          {id:'r11',type:'parent-child',person1:'p3',person2:'c4'},{id:'r12',type:'parent-child',person1:'p4',person2:'c4'},
          {id:'r13',type:'parent-child',person1:'p3',person2:'c5'},{id:'r14',type:'parent-child',person1:'p4',person2:'c5'}
        ]
      };

      try {
        await api('POST', '/import', s);
        showToast('Sample loaded');
        await loadFamily();
      } catch (e) {
        console.error(e);
        showToast('Sample load failed (check console)');
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  INIT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    loadFamily();

    document.addEventListener('keydown', e => {
      if (e.key === 'Escape') {
        closeMemberModal();
        closeRelModal();
        closeSettings();
        closeDetailPanel();
        closeMenu();
      }
    });

    document.querySelectorAll('.modal-overlay').forEach(el => {
      el.addEventListener('click', e => { if (e.target === el) el.classList.remove('active'); });
    });

    window.addEventListener('resize', () => { if (familyData.members.length) renderTree(); });
  </script>
</body>
</html>
